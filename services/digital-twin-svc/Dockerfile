# services/digital-twin-svc/Dockerfile

# --- Stage 1: Builder ---
# This stage uses an official SBT (Scala Build Tool) image to build the application.
# It contains the full JDK and SBT, which are needed for compilation but not for runtime.
FROM sbtscala/sbt:1.9.9 as builder

# Set the working directory.
WORKDIR /app

# Copy the build definition file.
COPY build.sbt .

# This command pre-fetches dependencies. It's a good practice to leverage
# Docker's layer caching, so dependencies are only re-downloaded if build.sbt changes.
RUN sbt update

# Copy the rest of the application source code.
COPY . .

# Build the application. This command compiles the Scala code and packages it
# into a single executable "fat JAR" using the sbt-assembly plugin (which would
# need to be added to plugins.sbt for a real project). For this example, we'll
# use a standard package command.
RUN sbt stage


# --- Stage 2: Final Image ---
# This stage creates the final, minimal image for deployment.
# We use an official Eclipse Temurin image, which provides a JRE.
FROM eclipse-temurin:17-jre-jammy

# Set the working directory.
WORKDIR /app

# Create a non-root user for security.
RUN addgroup --system app && adduser --system --group app
USER app

# Copy the packaged application from the 'builder' stage.
# The `sbt stage` command puts the output in `target/universal/stage`.
COPY --from=builder /app/target/universal/stage/ .

# The command to run when the container starts.
# It executes the runner script generated by SBT, which sets up the classpath
# and runs the main class.
# The `-Dhttp.port=8082` part passes a system property to override the port
# defined in application.conf, which is a common practice for containerized apps.
CMD ["bin/digital-twin-svc", "-Dhttp.port=8082"]
